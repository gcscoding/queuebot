package queuebot.bot;

import java.beans.Encoder;
import java.io.*;
import java.net.*;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.channels.*;
import java.nio.charset.*;
import java.util.*;
import java.util.logging.*;

import javax.swing.plaf.basic.BasicInternalFrameTitlePane.MaximizeAction;

import queuebot.queue.*;

public class QueueBot {
	private String _ircserv;
	private int _ircport;
	private String _ircchan;
	private String _ircnick;
	private String _ircuser;
	private String _ircrnam;
	private boolean firstPing;
	private boolean joined;
	private int _pingafter;
	private MessageQueue _mq;
	private String _goduser;
	private long lastPinged;
	private int _maxthreads;
	private int threadCount;
	private SocketChannel _sock;
	private StringBuilder builder;
	private ByteBuffer buf;
	private Charset chs;
	private CharsetEncoder enc;
	private CharsetDecoder dec;
//	private BufferedWriter out;
//	private BufferedReader in;
	private StringBuilder mlist;

	// THREADS

	public QueueBot(String ircserv, int ircport, String ircchan,
			String ircnick, String ircuser, String ircrnam, int pingafter,
			String goduser, int maxthreads) {
		_ircserv = ircserv;
		_ircport = ircport;
		_ircchan = ircchan;
		_ircnick = ircnick;
		_ircuser = ircuser;
		_ircrnam = ircrnam;
		_pingafter = pingafter;
		_goduser = goduser;
		_maxthreads = maxthreads;
		firstPing = false;
		joined = false;
		_mq = new MessageQueue();
		lastPinged = System.currentTimeMillis();
		threadCount = 0;
		builder = new StringBuilder();
		mlist = new StringBuilder();
		chs = Charset.forName("UTF-8");
		enc = chs.newEncoder();
		dec = chs.newDecoder();
		buf = ByteBuffer.allocate(4096);
		try {
			QueueBotLogger.makeLogFile();
		} catch (IOException e) {
			System.out.println("THERE WAS AN ERROR CREATING THE LOG FILES.");
			System.exit(1);
		}
	}

	public void start() {
		try {
			// _sock = new Socket(_ircserv, _ircport);
			// _sock.setSoTimeout(0);
			_sock = SocketChannel
					.open(new InetSocketAddress(_ircserv, _ircport));
			_sock.configureBlocking(false);
			boolean res = _sock.finishConnect();
			if (!res) {
				QueueBotLogger.log(Level.SEVERE, "ERROR CONNECTING TO SOCKET");
				return;
			}
			// out = new BufferedWriter(new OutputStreamWriter(
			// _sock.getOutputStream()));
			// in = new BufferedReader(new InputStreamReader(
			// _sock.getInputStream()));
			prepSend("NICK " + _ircnick + "\r\n");
			prepSend("USER " + _ircuser + " 0 * : " + _ircrnam + "\r\n");
			listen();
		} catch (IOException e) {
			QueueBotLogger.log(Level.SEVERE, e.getMessage());
		}
	}

	private void listen() {
		Selector sel = null;
		try {
			sel = Selector.open();
			_sock.register(sel, _sock.validOps());
		} catch (IOException e) {
			QueueBotLogger.log(Level.SEVERE, e.getMessage());
			return;
		}
		while (true) {
			if (joined
					&& toSeconds(System.currentTimeMillis() - lastPinged) >= _pingafter) {
				prepSend("PING ALIVE" + System.currentTimeMillis() + "\r\n");
				lastPinged = System.currentTimeMillis();
			}
			int numsel = 0;
			try {
				numsel = sel.select(500);
			} catch (IOException e) {
				QueueBotLogger.log(Level.SEVERE, e.getMessage());
				continue;
			}
			if (numsel > 0) {
				Iterator<SelectionKey> itr = sel.selectedKeys().iterator();
				while (itr.hasNext()) {
					SelectionKey selKey = itr.next();
					itr.remove();
					try {
						processSelKey(selKey);
					} catch (IOException e) {
						selKey.cancel();
					}
				}
			}
			// try {
			// char[] buf = new char[2048];
			// while (0 < in.read(buf)) {
			// processInput(String.valueOf(buf));
			// buf = new char[2048];
			// }
			// } catch (IOException e) {
			// QueueBotLogger.log(Level.SEVERE, e.getMessage());
			// }
		}
	}

	private void processSelKey(SelectionKey key) throws IOException {
		if (key.isValid() && key.isConnectable()) {
			SocketChannel ch = (SocketChannel) key.channel();
			boolean success = ch.finishConnect();
			if (!success) {
				key.cancel();
			}
		}
		if (key.isValid() && key.isWritable()) {
			SocketChannel ch = (SocketChannel) key.channel();
			sureSend(ch);
		}
		if (key.isValid() && key.isReadable()) {
			SocketChannel ch = (SocketChannel) key.channel();
			String msg = readFrom(ch);
			if (msg != null && !msg.isEmpty()) {
				processInput(msg);
			}
		}
		
	}

	private void quit() {
		try {
//			in.close();
//			out.close();
			_sock.close();
		} catch (IOException e) {
			QueueBotLogger.log(Level.SEVERE, e.getMessage());
		}

	}

	private void processInput(String msg) {
		builder.append(msg);
		String[] lines = builder.toString().split("\r\n");
		builder.setLength(0);
		if(lines.length <= 1) {
			builder.append(msg);
			return;
		}
		int i = 0;
		do {
			String line = lines[i];
			line = line.trim();
//			QueueBotLogger.log(Level.INFO, line);
			handleMsg(line);
			i++;
		} while (i < lines.length);
	}
	
	private void handleMsg(String msg) {
		String[] parts = msg.split(" ");
		if ("PING".equals(parts[0])) {
			String pong = msg.replaceAll("PING", "PONG");
			prepSend(pong + "\r\n");
			if (!firstPing) {
				firstPing = true;
			}
		}
		if (firstPing) {
			if (joined) {
				if (parts.length > 3) {
					if ("PRIVMSG".equals(parts[1]) && _ircnick.equals(parts[2])) {
						String uname = getUsername(msg.substring(1));
						String body = msg.split(_ircnick + " :")[1];
//						QueueBotLogger.log(Level.INFO, "MESSAGE RECEIVED: "
//								+ body + "\nANALYZING FOR COMMANDS");
						while(!spawnThread(uname, body));
					}
				}
			} else if (!joined && msg.indexOf("MODE " + _ircnick + " +i") > 0) {
				join();
			} else if (!joined) {
				String uname = getUsername(msg);
				if ((":" + _ircnick).equals(uname)) {
					if ("JOIN".equals(parts[1])
							&& _ircchan.compareToIgnoreCase(parts[2]) == 0) {
						joined = true;
					}
				}
			}
		}
	}

	private boolean spawnThread(String uname, String body) {
		if(threadCount >= _maxthreads) {
			return false;
		} else {
			incTC();
			Thread t = new Thread(new QueueBotThread(this, uname, body, _goduser));
			t.setDaemon(true);
			t.start();
//			QueueBotLogger.log(Level.INFO, "SPAWNED THREAD. CURRENT THREAD COUNT: " + threadCount);
			return true;
		}
	}
	
	public void incTC() {
		threadCount++;
	}
	
	public void decTC() {
		threadCount--;
	}
	
	private void join() {
		prepSend("JOIN " + _ircchan + "\r\n");
		prepSend("MODE " + _ircchan + "\r\n");
		prepSend("WHO " + _ircchan + "\r\n");
	}

	public MessageQueue getQueue() {
		return _mq;
	}

	private String getUsername(String line) {
		String[] parts = line.split("!");
		if (parts.length > 1) {
			return parts[0];
		} else {
			return null;
		}
	}
	
	private int toSeconds(long milli) {
		return (int) (milli / 1000);
	}

	private String readFrom(SocketChannel ch) {
		try {
			buf.clear();
			ch.read(buf);
			buf.flip();
			CharBuffer cbuf = dec.decode(buf);
			return cbuf.toString();
		} catch (IOException e) {
			QueueBotLogger.log(Level.SEVERE, e.getMessage());
			return null;
		}
	}

	protected void prepSend(String msg) {
		mlist.append(msg);
	}

	private void sureSend(SocketChannel ch) {
		// try {
		// out.write(msg);
		// out.flush();
		// QueueBotLogger.log(Level.INFO, msg.trim());
		// } catch (IOException e) {
		// QueueBotLogger.log(
		// Level.SEVERE,
		// "FAILED TO SEND MESSAGE: " + msg.trim() + "\n"
		// + e.getMessage());
		// sureSend(msg);
		// }
		try {
			int bcount = 0;
			buf.clear();
//			while(!mlist.isEmpty() && (bcount + mlist.get(0).length()) <= buf.capacity()) {
//				String m = mlist.remove(0);
//				buf.put(m.getBytes());
//			}
			String m;
			if(mlist.length() < buf.capacity()) {
				m = mlist.toString();
				mlist.setLength(0);
			} else {
				m = mlist.substring(0, buf.capacity());
				mlist.delete(0, buf.capacity());
			}
			buf.put(m.getBytes());
			buf.flip();
			while(buf.hasRemaining()) {
				ch.write(buf);
			}
			
//			if (!mlist.isEmpty()) {
//				String n = mlist.remove(0);
//				int wr = 0;
//				do {
//					wr = 0;
//					buf.clear();
//					buf.put(n.getBytes());
//					buf.flip();
//					while (buf.hasRemaining()) {
//						wr += ch.write(buf);
//					}
//					if (wr < n.length()) {
//						mlist.add(0, n);
//					} else {
////						QueueBotLogger.log(Level.INFO, "WROTE " + wr
////								+ " BYTES TO SOCKET: " + n.trim());
//						if (!mlist.isEmpty()) {
//							n = mlist.remove(0);
//						} else {
//							break;
//						}
//					}
//					
//				} while (wr > 0);
//			}
		} catch (IOException e) {
			QueueBotLogger.log(Level.SEVERE,
					"FAILED TO SEND MESSAGE\n" + e.getMessage());
		}
	}
	
	private class QueueBotThread implements Runnable {
		private QueueBot _bot;
		private MessageQueue _mq;
		private String _u;
		private String _b;
		private String _gu;
		
		public QueueBotThread(QueueBot b, String uname, String body, String gu) {
			_bot = b;
			_u = uname;
			_b = body;
			_mq = _bot.getQueue();
			_gu = gu;
		}
		public void run() {
			parse(_u, _b);
			_bot.decTC();
		}
		
		
		
		private void parse(String uname, String line) {
			String[] parts = line.split(" ");
			if ("!ask".equals(parts[0])) {
//				QueueBotLogger.log(Level.INFO, "FOUND COMMAND: !ask");
				parts[0] = "";
				if (_mq.getLength() >= MessageQueue.MAXLEN) {
					_bot.prepSend("PRIVMSG "
							+ uname
							+ " :Sorry, but the queue is at capacity right now. Please ask again after it has been cleared.\r\n");
					return;
				}
				StringBuilder b = new StringBuilder();
				for (String p : parts) {
					b.append(p);
					b.append(" ");
				}
				String s = b.toString().trim();
				Message m = new Message(new String[] { uname, s }, null, null);
				_mq.enqueue(m);
				_bot.prepSend("PRIVMSG " + uname + " :Added your message: \"" + s
						+ "\" to the queue. Your position in queue is "
						+ _mq.getLength() + ".\r\n");
			} else if ("!get".equals(parts[0])) {
//				QueueBotLogger.log(Level.INFO, "FOUND COMMAND: !get");
				boolean res = verifyUname(uname);
				if (res) {
					int num = 1;
					if (parts.length == 2) {
						try {
							num = Integer.parseInt(parts[1]);
						} catch (NumberFormatException e) {
							num = 1;
						}
					}
					for (int i = 0; i < num; i++) {
						Message item = _mq.dequeue();
						if (item != null) {
							_bot.prepSend("PRIVMSG " + _goduser + " :"
									+ item.getContent()[0] + " asked: "
									+ item.getContent()[1] + "\r\n");
							_bot.prepSend("PRIVMSG " + _ircchan + " :"
									+ item.getContent()[0] + " asked: "
									+ item.getContent()[1] + "\r\n");
						} else {
							_bot.prepSend("PRIVMSG " + _goduser
									+ " :MESSAGE QUEUE EMPTY\r\n");
						}
					}
				} else {
					QueueBotLogger.log(Level.WARNING, "INVALID USER ACCESS: "
							+ uname);
				}
			} else if ("!trim".equals(parts[0])) {
//				QueueBotLogger.log(Level.INFO, "FOUND COMMAND: !trim");
				boolean res = verifyUname(uname);
				if (res) {
					if (parts.length != 2) {
						_bot.prepSend("PRIVMSG " + _goduser
								+ " :Invalid usage. Proper usage: !trim X\r\n");
						return;
					}
					try {
						int num = Integer.parseInt(parts[1]);
						_mq.trim(num);
					} catch (NumberFormatException e) {
						_bot.prepSend("PRIVMSG " + _goduser
								+ " :Invalid usage. Proper usage: !trim X\r\n");
					}
				} else {
					QueueBotLogger.log(Level.WARNING, "INVALID USER ACCESS: "
							+ uname);
				}
			} else if ("!clear".equals(parts[0])) {
//				QueueBotLogger.log(Level.INFO, "FOUND COMMAND: !clear");
				boolean res = verifyUname(uname);
				if (res) {
					_mq.clear();
				} else {
					QueueBotLogger.log(Level.WARNING, "INVALID USER ACCESS: "
							+ uname);
				}
			} else if ("!count".equals(parts[0])) {
//				QueueBotLogger.log(Level.INFO, "FOUND COMMAND: !count");
				_bot.prepSend("PRIVMSG " + uname + " :There are currently "
						+ _mq.getLength() + " messages in the queue.\r\n");
			} else if ("!help".equals(parts[0])) {
//				QueueBotLogger.log(Level.INFO, "FOUND COMMAND: !help");
				boolean res = verifyUname(uname);
				_bot.prepSend("PRIVMSG " + uname + " :!ask QUESTION\r\n");
				_bot.prepSend("PRIVMSG " + uname + " :!count\r\n");
				if (res) {
					_bot.prepSend("PRIVMSG " + uname + " :!get [X]\r\n");
					_bot.prepSend("PRIVMSG " + uname + " :!trim X\r\n");
					_bot.prepSend("PRIVMSG " + uname + " :!clear\r\n");
				}
			}
		}
		
		private boolean verifyUname(String uname) {
			return _gu.equals(uname);
		}
		
		
	}
}
